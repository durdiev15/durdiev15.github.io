<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Phase-Field Modeling and Simulation of Ferroelectric Domain Evolution</title>
  <link rel="stylesheet" href="../../css/style.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script>
    MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
        }
    };
</script>

  <!-- <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script> -->
    <!-- Highlight.js CSS for a theme (e.g., "Atom One Dark") -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-light.min.css" rel="stylesheet" />
    <!-- Highlight.js JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>
<body>
  <header style="position: fixed; width: 100%;">
    <h1>Phase-Field Simulation of Ferroelectric Domain Evolution (Part 2)</h1>
    <nav>
        <a href="../../index.html">Home</a>
        <a href="../../projects.html">Projects</a>
    </nav>
  </header>

  <main>
    <section style="margin-top: 100px;">
        <!-- <nav id="toc"> -->
        <div class="toc">
            <h1 style="color: #01579b; font-weight: bold; font-size: 30px;"> Table of Contents</h1>
            <ul>
                <li><a href="#introduction"> Part 2: Numerical Implementation</a></li>
                
                <ul>
                  <li><a href="#section1">Non-Dimensionalization</a></li>
                    <li><a href="#fourier_frequency">Fourier Frequency</a></li>
                    <li><a href="#green_function">Green's Function</a></li>
                    <li><a href="#solver">FFT-based Solver</a></li>
                    <li><a href="#calculate_derivatives">Calculating Derivatives</a></li>
                    <li><a href="#energies_and_their_derivatives">Energy Calculations and Their Derivatives</a></li>
                    <li><a href="#data_management">Data Management</a></li>
                    <ul>
                      <li><a href="#vtk">Option 1: Writing Polarization Data to VTK Files</a></li>
                      <li><a href="#h5py">Option 2: Storing Data Using HDF5</a></li>
                    </ul>
                    <li><a href="#materials_parameters">Material Parameters</a></li>
                    <li><a href="#evolve_polarization">Polarization Dynamics</a></li>
                    <li><a href="#main">Execute Simulation</a></li>
                </ul>
            </ul>
        </div>
        <!-- </nav> -->
    </section>

    <section>
      <div class="toc-dropdown">
        <h1 style="color: #01579b; font-weight: bold; font-size: 30px;"> Table of Contents</h1>
        <ul>
            <li><a href="#introduction"> Part 2: Numerical Implementation</a></li>
            
            <ul>
              <li><a href="#section1">Non-Dimensionalization</a></li>
                <li><a href="#fourier_frequency">Fourier Frequency</a></li>
                <li><a href="#green_function">Green's Function</a></li>
                <li><a href="#solver">FFT-based Solver</a></li>
                <li><a href="#calculate_derivatives">Calculating Derivatives</a></li>
                <li><a href="#energies_and_their_derivatives">Energy Calculations and Their Derivatives</a></li>
                <li><a href="#data_management">Data Management</a></li>
                <ul>
                  <li><a href="#vtk">Option 1: Writing Polarization Data to VTK Files</a></li>
                  <li><a href="#h5py">Option 2: Storing Data Using HDF5</a></li>
                </ul>
                <li><a href="#materials_parameters">Material Parameters</a></li>
                <li><a href="#evolve_polarization">Polarization Dynamics</a></li>
                <li><a href="#main">Execute Simulation</a></li>
            </ul>
        </ul>
    </div>
    </section>

<div class="container">
<section id="introduction">
  <h1>Part 2: Numerical Implementation</h1>
  <p>
      In <a href="part_1.html" target="_blank">Part-1</a>, we developed the phase-field model, derived the governing equations, and introduced the Fourier spectral method. We also built algorithms to solve the coupled piezoelectric equations and a semi-implicit algorithm for the time-dependent Ginzburg-Landau equation.
  </p>
  <p>
      Now, in Part-2, we will implement these algorithms in Python using 
      <b>PyTorch</b>. While PyTorch is widely known as a machine learning library, 
      it offers powerful tools like Fast Fourier Transform (FFT) and Einstein summation, 
      which are faster than their counterparts in NumPy or SciPy. Moreover, 
      PyTorch allows us to run computations on GPUs, enabling significant acceleration 
      by submitting scripts as jobs on a GPU cluster. This makes PyTorch an excellent choice for our simulations.
  </p>
  <p>
    <b>Python Code Structure for Simulations:</b>
  </p>
  <ul>
    <li><code>main.py</code>: The main file executed to run the simulation. It contains simulation parameters and imports the <code>evolve_polarization</code> module.</li>
    <li><code>evolve_polarization.py</code>: Contains the polarization evolution function. Imports modules for parameters, piezoelectric and strain tensor calculation, energy calculation, Fourier frequency calculation, VTK file writing, Green's function calculation, and the piezoelectricity solver.</li>
    <li><code>parameters.py</code>: Stores all material parameters used in the simulation.</li>
    <li><code>piezo_strain_tensor.py</code>: Calculates the piezoelectric and spontaneous strain tensor and its derivative.</li>
    <li><code>energy.py</code>: Calculates bulk energy and its derivative.</li>
    <li><code>fourier_frequency.py</code>: Calculates Fourier frequencies.</li>
    <li><code>write_vtk.py</code>: Provides functionality to write simulation results to VTK files in 3D.</li>
    <li><code>greens_function.py</code>: Calculates the Green's function in Fourier space.</li>
    <li><code>solver.py</code>: Solves the piezoelectric constitutive and balance equations.</li>
  </ul>
</section>

<section id="section1">
  <h1>Non-Dimensionalization</h1>
  <p>
    Non-dimensionalization is a crucial step when working with equations in simulations, 
    especially in phase-field modeling of ferroelectric domains. By removing units from the equations, 
    we simplify the mathematics and make the simulation more general. This step helps ensure that the results 
    can be easily scaled to different physical systems and reduces the chance of numerical errors due to the 
    large or small magnitudes of physical constants.
  </p>
  <p>
    Once we non-dimensionalize the equations, they are ready for numerical implementation. 
    The dimensionless form ensures that the computations are efficient and robust, regardless of the 
    specific physical scale of the system being studied. Next, we will show how to apply non-dimensionalization 
    to the governing equations step by step, preparing them for use in our simulations.
  </p>
  <p>
    So, we have the following phase-field equation:
    \begin{equation}\label{app:PFeq}
    \beta\frac{\partial P_i}{\partial t}= \kappa_{\rm grad} \frac{G l}{P_0^2} P_{i,jj} - \kappa_{\rm sep}\frac{G}{l} \frac{\partial\tilde{\psi}}{\partial P_i}-\frac{\partial H^{\rm bulk}}{\partial P_i} .
    \end{equation}
    The physical quantities we have are polarization ($P$ and $P_0$), 
    mobility coefficient ($\beta$), domain wall width ($l$), domain wall energy ($G$), time ($t$) and energy density $H$.
    Their units are:
    \begin{equation}\label{app:units}
        P, P_0\rightarrow \bigg[\frac{\text{C}}{\text m^2}\bigg], 
        \quad \beta^{-1}\rightarrow\bigg[\frac{\text J \text m \text s}{\text C^2}\bigg],  
        \quad G \rightarrow \bigg[\frac{\text J}{\text m^2}\bigg], 
        \quad H\rightarrow\bigg[\frac{\text J}{\text m^3}\bigg]
    \end{equation}
    Dimensionless forms of the quantities follow from division by a relevant scaling parameter (subscript s),
    \begin{equation*}
        \begin{split}
          \tilde{P}=\frac{P}{P_s}, 
          \quad \tilde{t}=\frac{t}{t_s}, 
          \quad \tilde{H}=\frac{H}{H_s} 
          \quad \tilde{  r}=\frac{  r}{r_s}, 
          \quad \tilde \beta = \frac{\beta}{\beta_s}
      \end{split}
    \end{equation*}
    which we choose here as
    \begin{equation*}
        P_s = P_0, 
        \quad t_s=10^{-12} \; [\text{s}], 
        \quad H_s = \frac{G}{l}, 
        \quad r_s=l, 
        \quad \beta_s = \frac{G t_s}{lP_0^2}
    \end{equation*}
    then
    \begin{equation}
    \tilde{\beta} \frac{G t_s}{lP_0^2} \frac{P_0}{t_s}\frac{\partial \tilde P_i}{\partial \tilde t} = 
    \kappa_{\rm grad} \frac{G l}{P_0^2} \frac{P_0}{l^2} \tilde P_{i,jj} 
    - \kappa_{\rm sep}\frac{G}{l} \frac{1}{P_0}\frac{\partial\tilde{\psi}}{\partial \tilde P_i}
    - \frac{G}{lP_0}\frac{\partial \tilde H^{\rm bulk}}{\partial \tilde P_i}.
    \end{equation}
    Finally, our non-dimensionalized phase-field equation is 
    \begin{equation}
    \tilde{\beta}\frac{\partial \tilde P_i}{\partial \tilde t} = 
    \kappa_{\rm grad} \tilde P_{i,jj} 
    - \kappa_{\rm sep}\frac{\partial\tilde{\psi}}{\partial \tilde P_i}
    - \frac{\partial \tilde H^{\rm bulk}}{\partial \tilde P_i}.
    \end{equation}
  </p>
  
</section>

<section id="fourier_frequency">
  <h2>
      Fourier Frequency
  </h2>
  <p> Fourier frequencies represent the wavevector components corresponding to the discretized grid. 
    In our simulations, we compute these frequencies using the FFT in 3D space.
  </p>
  <p>
    The Python function <code>fourier_frequency.py</code> provided calculates the Fourier frequencies for a 3D grid using PyTorch. 
    It takes the number of grid points and grid spacing in each spatial direction as inputs, along 
    with the computation device (CPU or GPU). The function then uses the <code>torch.fft.fftfreq</code> method 
    to compute the sample frequencies for each direction (x, y, z) and combines them into a 3D tensor grid.
  </p>
<pre><code class="language-python">import torch

def fourier_frequencies(Nx:int, dx:float, Ny:int, dy:float, Nz:int, dz:float, device:torch.device):
"""
Computes the FFT sample frequencies for a 3D

Nx, Ny, Nz - number of grid points in each direction

dx, dy, dz - grid spacing in each direction

device - torch device; "cpu" or "cuda"
"""
# in x-direction
kx = (2.0 * torch.tensor([torch.pi]) * torch.fft.fftfreq(Nx, dx)).to(device)

# in y-direction
ky = (2.0 * torch.tensor([torch.pi]) * torch.fft.fftfreq(Ny, dy)).to(device)

# in z-direction
kz = (2.0 * torch.tensor([torch.pi]) * torch.fft.fftfreq(Nz, dz)).to(device)

# Create grids of coordinates
kx_grid, ky_grid, kz_grid = torch.meshgrid(kx, ky, kz, indexing = 'ij')

# Concatenates a sequence of tensors
freq = torch.stack((kx_grid, ky_grid, kz_grid))

# Clean up
del kx, ky, kz, kx_grid, ky_grid, kz_grid

return freq
</code></pre>     
<p>
In Python, memory management is crucial, especially when working with large datasets or simulations. 
Using <code>del</code> to delete variables that are no longer needed helps free up memory. 
This is particularly important when dealing with large arrays or tensors, as these can consume 
significant amounts of memory.
</p>
</section>

<section id="green_function">
<h2>
  Green's Function
</h2>
<p>
  In <a href="part_1.html" target="_blank">Part-1</a>, 
  we demonstrated how to calculate the Green's functions in Fourier space. 
  Now, we present the Python code to implement these calculations. 
  After some derivations, we arrived at the following expressions:
\begin{equation}\label{b12}
    \begin{split}
        \hat{\Gamma}_{ijkl}^0 &= \frac{1}{4}(A_{ik}^{-1}\xi_l\xi_j + A_{il}^{-1}\xi_k\xi_j + A_{jl}^{-1}\xi_k\xi_i + A_{jl}^{-1}\xi_k\xi_i )
        \\
        \hat{\Phi}^0_{nij} &= \frac{1}{2} (A_{4j}^{-1}\xi_i\xi_n + A_{4i}^{-1}\xi_j\xi_n)
        \\
        \hat{\Lambda}_{ni}^0 &= A_{44}^{-1} \xi_n \xi_i.
    \end{split}
\end{equation}
</p>
<p>
  Here, we use a Python module called <code>greens_function.py</code> to compute these Green's functions efficiently. 
  It is important to note that the calculations require only volume-averaged material tensors,
   specifically the stiffness, piezoelectric, and dielectric tensors.
</p>
<p>
  With these expressions and the code, we can directly compute the Green's functions needed for our simulations.
</p>
<pre><code class="language-python">import torch
import itertools

def Green_Operator(C0:torch.Tensor, e0:torch.Tensor, K0:torch.Tensor,
                                            n:torch.Tensor, Nx:int, Ny:int, Nz:int, device:torch.device):

    """
    Calculates the Green's functions in Fourier spaces

    C0, e0, K0 - homogeneous material's stiffness, piezoelectric and dielectric tesnors

    n - Fourier frequencies

    Nx, Ny, Nz - number of grid points in each direction

    device - torch device; "cpu" or "cuda"
    """

    A_c = torch.einsum('pijq, p ..., q ... -> ij ...', C0, n, n)
    A_e = torch.einsum('piq, p ..., q ... -> i ...', e0, n, n)
    A_d = torch.einsum('pq, p ..., q ...', K0, n, n)

    # make the first element one
    A_d[0, 0, 0] = 1.0

    # Total matrix
    A = A_c + 1 / A_d * torch.einsum('i ..., j ... -> ij ...', A_e, A_e)

    # Find the inverse of A
    G = torch.einsum('ij ... -> ji ...', A)

    adjG = torch.empty_like(A, dtype=torch.float32)
    adjG[0,0] = G[1,1] * G[2,2] - G[1,2] * G[2,1]
    adjG[0,1] = -(G[1,0] * G[2,2] - G[1,2] * G[2,0])
    adjG[0,2] = G[1,0] * G[2,1] - G[1,1] * G[2,0]
    adjG[1,0] = -(G[0,1] * G[2,2] - G[0,2] * G[2,1])
    adjG[1,1] = G[0,0] * G[2,2] - G[0,2] * G[2,0]
    adjG[1,2] = -(G[0,0] * G[2,1] - G[0,1] * G[2,0])
    adjG[2,0] = G[0,1] * G[1,2] - G[0,2] * G[1,1]
    adjG[2,1] = -(G[0,0] * G[1,2] - G[0,2] * G[1,0])
    adjG[2,2] = G[0,0] * G[1,1] - G[0,1] * G[1,0]

    # Determinant of A
    detG = A[0,0] * (A[1,1] * A[2,2] - A[1,2] * A[2,1]) \
              - A[0,1] * (A[1,0] * A[2,2] - A[1,2] * A[2,0]) \
                  + A[0,2] * (A[1,0] * A[2,1] - A[1,1] * A[2,0])
    detG[0,0,0] = 1.0

    # Inverse of A
    invA = adjG/detG

    # Green's function of the stiffness tensor in Fourier space
    G_elas = torch.zeros((3, 3, 3, 3, Nx, Ny, Nz), dtype=torch.float32).to(device)
    for i,j,k,l in itertools.product(range(3), repeat=4):
        G_elas[i,j,k,l] = 0.25 * (invA[i, l] * n[k] * n[j] +
                                  invA[j, l] * n[k] * n[i] +
                                  invA[i, k] * n[l] * n[j] +
                                  invA[j, k] * n[i] * n[l])

    # Green's function of the piezoelectric tensor in Fourier space
    G_piezo = torch.zeros((3, 3, 3, Nx, Ny, Nz), dtype=torch.float32).to(device)
    for k,i,j in itertools.product(range(3), repeat=3):
        G_piezo[k,i,j] = 1/(2 * A_d) * n[k] * (invA[i, 0] * n[j] + invA[j, 0] * n[i]) * A_e[0] + 
                         1/(2 * A_d) * n[k] * (invA[i, 1] * n[j] + invA[j, 1] * n[i]) * A_e[1] + 
                         1/(2 * A_d) * n[k] * (invA[i, 2] * n[j] + invA[j, 2] * n[i]) * A_e[2]

    # Green's function of the dielectric tensor in Fourier space
    aga = torch.einsum('i..., ij..., j...', A_e, invA, A_e)
    G_dielec = 1/(A_d**2) * (aga - A_d) * torch.einsum('i ..., j ... -> ij ...', n, n)

    # delete unused tensors - save more memory
    del aga, invA, G, adjG, A_c, A_e, A_d

    # return the greens tensors
    return G_elas, G_piezo, G_dielec
</code></pre>

</section>

<section id="solver">
    <h2>FFT-based Solver</h2>
<p>
  In the previous part of this project, we developed the FFT-based algorithm. Now, we implement this algorithm in Python. 
  Since we have already calculated the Green's functions, we can directly compute the strain and electric fields. 
  This algorithm is versatile and can be applied not only to ferroelectric materials but also to other piezoelectric materials, 
  as it solves the coupled piezoelectric constitutive equations. The algorithm calculates the residuals for stress and electric displacement, 
  and the iterations stop when the maximum residual or error falls below a specified tolerance. In this case, we use a tolerance of 
  <code>tol=1e-4</code>. And let's call it <code>solver.py</code>
</p>
<pre><code class="language-python">import torch
from torch.fft import fftn as fft, ifftn as ifft

import math
import sys

def Solve_Piezoelectricity(C0:torch.Tensor, K0:torch.Tensor , e0:torch.Tensor, eP:torch.Tensor,
                                G_elas:torch.Tensor, G_piezo:torch.Tensor, G_dielec:torch.Tensor,
                                eps0:torch.Tensor, eps_ext:torch.Tensor, E_ext:torch.Tensor,
                                Nx:int, Ny:int, Nz:int, P:torch.Tensor,
                                number_interations = 100, tol = 1e-4):

    """
    Solves the constitutive and balance equations using FFT.
    Returns stress, electric displacement, elastic strain and total electric field

    C0, K0, e0 - homogeneous material's stiffness, piezoelectric and dielectric tesnors

    eP - heterogeneuos piezoelectric tensor

    G_elas, G_piezo, G_dielec - Calculateed Green's functions in Fourier space

    eps0 - sponteneous strain

    eps_ext - applied external strain

    E_ext - applied electric field

    Nx, Ny, Nz - number of grid points in each direction

    P - sponteneous polarization

    number_interations - number of interations, default is 100

    tol - given tolerance, default is 1e-4
    """

    # Initialize and change the dtype in Fourier space
    C0_complex = C0.to(torch.complex64)
    e0_complex = e0.to(torch.complex64)
    G_elas_complex = G_elas.to(torch.complex64)
    G_piezo_complex = G_piezo.to(torch.complex64)
    G_dielec_complex = G_dielec.to(torch.complex64)

    # Initialize the norms
    sig_norm = 1e-8
    D_norm = 1e-8

    # Initialize the total strain and electric field
    eps_tot = torch.zeros_like(eps0, dtype=torch.float32)
    E = torch.zeros_like(E_ext, dtype=torch.float32)

    # Apply FFT for the sponteneous polarization and strain
    P_fft = fft(P, dim=(1,2,3))
    eps0_fft = fft(eps0, dim=(2,3,4))

    # start the loop
    for itr in range(number_interations):

        # elastic strain
        eps_elas = eps_tot+eps_ext-eps0

        # total electric field: depolarization + applied
        E_tot = E + E_ext

        # constitutive equations, sigma & D
        sigma = torch.einsum('ijkl, klxyz -> ijxyz', C0, eps_elas) - torch.einsum('kijxyz, kxyz -> ijxyz', eP, E_tot)
        D = torch.einsum('ijkxyz, jkxyz -> ixyz', eP, eps_elas) + torch.einsum('ij, jxyz -> ixyz', K0, E_tot) + P

        # calculate the norms
        sig_norm_new = torch.norm(sigma.ravel(), p=2).item()
        D_norm_new = torch.norm(D.ravel(), p=2).item()

        # find the error
        err_s = abs((sig_norm_new - sig_norm) / sig_norm)
        err_d = abs((D_norm_new - D_norm )/ D_norm)

        # print iteration number and errors
        print(f"Iteration: {itr} | S. error = {err_s:.2E} | D. error = {err_d:.2E}")
        # print(f"Iteration: {itr} | S. error = {err_s} | D. error = {err_d}")

        # check for nan and inf errors and break the loop if the error is below 1e-4
        if math.isnan(err_s) is True or math.isinf(err_s) is True:
            print(f"Error: Iteration loop terminated due to the presence of NaN or Inf ")
            sys.exit()
        elif max(err_s,err_d) < tol:
            break

        # update the norms
        D_norm = D_norm_new
        sig_norm = sig_norm_new

        # determine the heterogeneuos stress tesnsor and elec. displacement vector
        tau = sigma - torch.einsum('ijkl, klxyz -> ijxyz', C0, eps_elas) + torch.einsum('kij, kxyz -> ijxyz', e0, E_tot)
        rho = D - torch.einsum('ijk, jkxyz -> ixyz', e0, eps_elas) - torch.einsum('ij, jxyz -> ixyz', K0, E_tot) - P

        # do FFT
        tau_fft = fft(tau, dim=(2,3,4))
        rho_fft = fft(rho, dim=(1,2,3))

        # get alpha and beta
        alpha = tau_fft-torch.einsum('ijkl, klxyz -> ijxyz', C0_complex, eps0_fft)
        beta = rho_fft + P_fft - torch.einsum('ijk, jkxyz -> ixyz', e0_complex, eps0_fft)

        # Calculate the total strain in Fourier space
        eps_tot_fft = -torch.einsum('ijklxyz, klxyz -> ijxyz', G_elas_complex, alpha) - torch.einsum('kijxyz, kxyz -> ijxyz', G_piezo_complex, beta)
        eps_tot_fft[:,:,0,0] = 0

        # Calculate the total electric field in Fourier space
        E_fft = torch.einsum('ijkxyz, jkxyz -> ixyz', G_piezo_complex, alpha) + torch.einsum('ijxyz, jxyz -> ixyz', G_dielec_complex, beta)
        E_fft[:,0,0] = 0

        # In real space
        eps_tot = ifft(eps_tot_fft, dim=(2,3,4)).real
        E = ifft(E_fft, dim=(1,2,3)).real

    # delete unused tensors to save more memory
    del eps_tot, E, P_fft, eps0_fft, tau, rho
    del tau_fft, rho_fft, alpha, beta, E_fft, eps_tot_fft

    # return stress, electric displacement, elastic strain and total electric field
    return sigma, D, eps_elas, E_tot
</code></pre>

    
</section>

<section id="calculate_derivatives">
    <h2>Calculating Derivatives</h2>
    <p>
      Accurately calculating derivatives is essential in phase-field simulations, as even a minor error, like a sign mistake, can lead to incorrect results and completely ruin the simulation. In these simulations, we often need to compute the derivative of the order parameter with respect to the total energy density.
    </p>
    <p>
      In general, material tensors typically depend on the order parameter, which in our case is the polarization. For simplicity, we assume that only the piezoelectric tensor depends on polarization. This dependency introduces the need to calculate the first-order derivatives of this tensor with respect to polarization.
    </p>
    <p>
      The piezoelectric tensor has 27 components, and due to symmetry, we can reduce this to 18 unique components. However, manually deriving the first-order derivative for each component is extremely tedious and error-prone. Additionally, entering these derivatives into Python manually would be time-consuming and likely introduce mistakes.
    </p>
    <p>
      To address this, we leverage symbolic differentiation using the <b>SymPy</b> library in Python. SymPy allows us to compute these derivatives analytically and accurately without the need to perform the tedious calculations by hand. This approach ensures that the derivatives are correct and saves us significant time and effort during implementation.
    </p>
<p>
  We have the following 3rd-order piezoelectric tensor:
  \begin{equation}\label{eq5}
            \begin{split}
                e_{ijk}(P_i)=&\bigg( \frac{|{P_i}|}{P_0} \bigg)^3 \Big\{e_{33} n_i n_j n_k + e_{31} (\delta_{ij} - n_i n_j) n_k \\ &+ \frac{1}{2} e_{15} \big[ (\delta_{ki}- n_k n_i) n_j + (\delta_{kj}- n_k n_j) n_j \big] \Big\},
            \end{split}
            \end{equation}
  Let's rewrite this in terms of the polarization ($n_i = P_i /|\boldsymbol{P}|$):
  \begin{equation}
      e_{kij}(P_i)=P_iP_jP_k (e_{33}-e_{31}-e_{15}) + |P|^2 \left(e_{31} \delta_{ij} P_k + \frac{e_{15}}{2}( I_{ki} P_j + \delta_{kj} P_i ) \right)
  \end{equation}
</p>
<pre><code class="language-python">import sympy as sp
import itertools

# Define the symbols for P components and other parameters
P1, P2, P3 = sp.symbols('P1 P2 P3')  # P vector components
e33, e31, e15, em = sp.symbols('e33 e31 e15 em')  # Other symbols em = e33 - e31 - e15
I = sp.eye(3)  # Identity matrix (Kronecker delta)
norm_sq = P1**2 + P2**2 + P3**2
# Define the tensor eP symbolically
eP = sp.MutableDenseNDimArray.zeros(3, 3, 3)

# Populate eP based on the provided formula
for k, i, j in itertools.product(range(3), repeat=3):
    eP[k, i, j] = (
        P1 * P2 * P3 * em +
        norm_sq * (
            e31 * I[i, j] * [P1, P2, P3][k] +
            e15 / 2 * (I[k, i] * [P1, P2, P3][j] + I[k, j] * [P1, P2, P3][i])
        )
    )

# Compute the derivatives of eP with respect to each component of P
# Derivative wrt P1, deP_dP1
for i, j, k in itertools.product(range(3), repeat=3):
    print(f"deP_dP1[{i}, {j}, {k}] = {eP[i,j,k].diff(P1)}")

# Derivative wrt P2, deP_dP2
for i, j, k in itertools.product(range(3), repeat=3):
    print(f"deP_dP2[{i}, {j}, {k}] = {eP[i,j,k].diff(P2)}")

# Derivative wrt P3, deP_dP3
for i, j, k in itertools.product(range(3), repeat=3):
    print(f"deP_dP3[{i}, {j}, {k}] = {eP[i,j,k].diff(P3)}")  
</code></pre>
<p>
  Run the code provided above to compute the derivatives of the tensor eP with respect to <code>P1</code>, 
  <code>P2</code> and <code>P3</code>. The output will display the symbolic derivatives for each component. 
  Once you have these expressions, copy them into a new Python file, which we can name <code>piezo_strain_tensor.py</code>.
</p>
<p>
  While it is possible to convert the symbolic expressions into Python functions using <code>sympy.lambdify()</code>, 
  this approach may not be ideal for simulations. Given the large number of components in the tensor, 
  generating and evaluating these functions dynamically during every simulation run could introduce unnecessary 
  computational overhead.
</p>
<p>
Instead, saving the precomputed symbolic derivatives as hardcoded functions in a separate script ensures that
 the derivatives are readily available in a form optimized for numerical computations. This approach reduces 
 runtime overhead and makes the simulation code more efficient.
</p>
<pre><code class="language-python">import torch
import itertools

def Piezo_Strain_Tensor(P:torch.Tensor, e33:float, e31:float, e15:float, e00:float,
                        device:torch.device):

    """
    Calculates the piezoelectric and spontaneous strain tensors
    Returns the piezoelectric tesnor, homogeneous piezoelectric tensor, sponteneous strain tensor

    P - spontaneous polarization

    e33, e31, e15 - piezoelectric tensor components in ferroelectric phase

    e00 - maximum remanent strain

    device - the device, "cpu" or "cuda"
    """

    # Get the square root of the polarization norm
    norm_sq = P[0]**2 + P[1]**2 + P[2]**2     # norm of the polarizatioin vector P

    # Unit tensor
    I = torch.eye(3).to(device)

    # Initialize the piezoelectric tensor
    eP = torch.zeros((3, 3, 3, *P[0].shape)).to(device)         # P dependen piez. tensor
    for k, i, j in itertools.product(range(3), repeat=3):
        eP[k, i, j] = (P[i] * P[j] * P[k] * (e33 - e31 - e15) + norm_sq * (e31 * I[i, j] * P[k]
                            + e15/2 * (I[k, i] * P[j] + I[k, j] * P[i])))

    # homogeneous piez. tensor, volume average of e(P)
    e0 = torch.zeros((3, 3, 3)).to(device)
    for i, j, k in itertools.product(range(3), repeat=3):
        e0[i, j, k] = torch.mean(eP[i, j, k])

    # spontaneous strain, depends on P
    eps0 = torch.zeros((3, 3, *P[0].shape)).to(device)
    for i, j in itertools.product(range(3), repeat=2):
        eps0[i, j] = 1.5 * e00 * (P[i] * P[j] - 1/3 * norm_sq * I[i, j])

    # return piezoelectric tesnor, homogeneous piezoelectric tensor, sponteneous strain tensor
    return eP, e0, eps0


def Piezo_Strain_Tensor_Derivative(P, e33, e31, e15, e00, device):

    """
    Calculates the derivative of the piezoelectric tesnor and sponteneous strain tensor
    wrt polarization P.

    Returns the derivatives

    P - spontaneous polarization

    e33, e31, e15 - piezoelectric tensor components in ferroelectric phase

    e00 - maximum remanent strain

    device - the device, "cpu" or "cuda"
    """

    # --------------- Derivaive of the piezoelectric tensor wrt P --------------
    norm_sq = P[0]**2 + P[1]**2 + P[2]**2     # norm of the polarizatioin vector P

    deP_dPx = torch.zeros((3,3,3,*P[0].shape)).to(device)        # derivative wrt P[0]
    deP_dPy = torch.zeros((3,3,3,*P[0].shape)).to(device)       # derivative wrt P[1]
    deP_dPz = torch.zeros((3,3,3,*P[0].shape)).to(device)        # derivative wrt P[2]

    em = -e15 - e31 + e33

    deP_dPx[0,0,0] = 3*P[0]**2*em  + 2*P[0]*(P[0]*e15 + P[0]*e31) + (e15 + e31)*norm_sq
    deP_dPy[0,0,0] = 2*P[1]*(P[0]*e15 + P[0]*e31)
    deP_dPz[0,0,0] = 2*P[2]*(P[0]*e15 + P[0]*e31)

    deP_dPx[0,0,1] = P[0]*P[1]*e15 + 2*P[0]*P[1]*em
    deP_dPy[0,0,1] = P[0]**2*em  + P[1]**2*e15 + e15*norm_sq/2
    deP_dPz[0,0,1] = P[1]*P[2]*e15

    deP_dPx[0,0,2] = P[0]*P[2]*e15 + 2*P[0]*P[2]*em
    deP_dPy[0,0,2] = P[1]*P[2]*e15
    deP_dPz[0,0,2] = P[0]**2*em  + P[2]**2*e15 + e15*norm_sq/2

    deP_dPx[0,1,0] = deP_dPx[0,0,1]#P[0]*P[1]*e15 + 2*P[0]*P[1]*em
    deP_dPy[0,1,0] = deP_dPy[0,0,1]#P[0]**2*em  + P[1]**2*e15 + e15*norm_sq/2
    deP_dPz[0,1,0] = deP_dPz[0,0,1]#P[1]*P[2]*e15

    deP_dPx[0,1,1] = 2*P[0]**2*e31 + P[1]**2*em  + e31*norm_sq
    deP_dPy[0,1,1] = 2*P[0]*P[1]*e31 + 2*P[0]*P[1]*em
    deP_dPz[0,1,1] = 2*P[0]*P[2]*e31

    deP_dPx[0,1,2] = P[1]*P[2]*em
    deP_dPy[0,1,2] = P[0]*P[2]*em
    deP_dPz[0,1,2] = P[0]*P[1]*em

    deP_dPx[0,2,0] = deP_dPx[0,0,2]#P[0]*P[2]*e15 + 2*P[0]*P[2]*em
    deP_dPy[0,2,0] = deP_dPy[0,0,2]#P[1]*P[2]*e15
    deP_dPz[0,2,0] = deP_dPz[0,0,2]#P[0]**2*em  + P[2]**2*e15 + e15*norm_sq/2

    deP_dPx[0,2,1] = deP_dPx[0,1,2]#P[1]*P[2]*em
    deP_dPy[0,2,1] = deP_dPy[0,1,2]#P[0]*P[2]*em
    deP_dPz[0,2,1] = deP_dPz[0,1,2]#P[0]*P[1]*em

    deP_dPx[0,2,2] = 2*P[0]**2*e31 + P[2]**2*em  + e31*norm_sq
    deP_dPy[0,2,2] = 2*P[0]*P[1]*e31
    deP_dPz[0,2,2] = 2*P[0]*P[2]*e31 + 2*P[0]*P[2]*em

    deP_dPx[1,0,0] = 2*P[0]*P[1]*e31 + 2*P[0]*P[1]*em
    deP_dPy[1,0,0] = P[0]**2*em  + 2*P[1]**2*e31 + e31*norm_sq
    deP_dPz[1,0,0] = 2*P[1]*P[2]*e31

    deP_dPx[1,0,1] = P[0]**2*e15 + P[1]**2*em  + e15*norm_sq/2
    deP_dPy[1,0,1] = P[0]*P[1]*e15 + 2*P[0]*P[1]*em
    deP_dPz[1,0,1] = P[0]*P[2]*e15

    deP_dPx[1,0,2] = P[1]*P[2]*em
    deP_dPy[1,0,2] = P[0]*P[2]*em
    deP_dPz[1,0,2] = P[0]*P[1]*em

    deP_dPx[1,1,0] = deP_dPx[1,0,1]#P[0]**2*e15 + P[1]**2*em  + e15*norm_sq/2
    deP_dPy[1,1,0] = deP_dPy[1,0,1]#P[0]*P[1]*e15 + 2*P[0]*P[1]*em
    deP_dPz[1,1,0] = deP_dPz[1,0,1]#P[0]*P[2]*e15

    deP_dPx[1,1,1] = 2*P[0]*(P[1]*e15 + P[1]*e31)
    deP_dPy[1,1,1] = 3*P[1]**2*em  + 2*P[1]*(P[1]*e15 + P[1]*e31) + (e15 + e31)*norm_sq
    deP_dPz[1,1,1] = 2*P[2]*(P[1]*e15 + P[1]*e31)

    deP_dPx[1,1,2] = P[0]*P[2]*e15
    deP_dPy[1,1,2] = P[1]*P[2]*e15 + 2*P[1]*P[2]*em
    deP_dPz[1,1,2] = P[1]**2*em  + P[2]**2*e15 + e15*norm_sq/2

    deP_dPx[1,2,0] = deP_dPx[1,0,2]#P[1]*P[2]*em
    deP_dPy[1,2,0] = deP_dPy[1,0,2]#P[0]*P[2]*em
    deP_dPz[1,2,0] = deP_dPz[1,0,2]#P[0]*P[1]*em

    deP_dPx[1,2,1] = deP_dPx[1,1,2]#P[0]*P[2]*e15
    deP_dPy[1,2,1] = deP_dPy[1,1,2]#P[1]*P[2]*e15 + 2*P[1]*P[2]*em
    deP_dPz[1,2,1] = deP_dPz[1,1,2]#P[1]**2*em  + P[2]**2*e15 + e15*norm_sq/2

    deP_dPx[1,2,2] = 2*P[0]*P[1]*e31
    deP_dPy[1,2,2] = 2*P[1]**2*e31 + P[2]**2*em  + e31*norm_sq
    deP_dPz[1,2,2] = 2*P[1]*P[2]*e31 + 2*P[1]*P[2]*em

    deP_dPx[2,0,0] = 2*P[0]*P[2]*e31 + 2*P[0]*P[2]*em
    deP_dPy[2,0,0] = 2*P[1]*P[2]*e31
    deP_dPz[2,0,0] = P[0]**2*em  + 2*P[2]**2*e31 + e31*norm_sq

    deP_dPx[2,0,1] = P[1]*P[2]*em
    deP_dPy[2,0,1] = P[0]*P[2]*em
    deP_dPz[2,0,1] = P[0]*P[1]*em

    deP_dPx[2,0,2] = P[0]**2*e15 + P[2]**2*em  + e15*norm_sq/2
    deP_dPy[2,0,2] = P[0]*P[1]*e15
    deP_dPz[2,0,2] = P[0]*P[2]*e15 + 2*P[0]*P[2]*em

    deP_dPx[2,1,0] = deP_dPx[2,0,1]#P[1]*P[2]*em
    deP_dPy[2,1,0] = deP_dPy[2,0,1]#P[0]*P[2]*em
    deP_dPz[2,1,0] = deP_dPz[2,0,1]#P[0]*P[1]*em

    deP_dPx[2,1,1] = 2*P[0]*P[2]*e31
    deP_dPy[2,1,1] = 2*P[1]*P[2]*e31 + 2*P[1]*P[2]*em
    deP_dPz[2,1,1] = P[1]**2*em  + 2*P[2]**2*e31 + e31*norm_sq

    deP_dPx[2,1,2] = P[0]*P[1]*e15
    deP_dPy[2,1,2] = P[1]**2*e15 + P[2]**2*em  + e15*norm_sq/2
    deP_dPz[2,1,2] = P[1]*P[2]*e15 + 2*P[1]*P[2]*em

    deP_dPx[2,2,0] = deP_dPx[2,0,2]#P[0]**2*e15 + P[2]**2*em  + e15*norm_sq/2
    deP_dPy[2,2,0] = deP_dPy[2,0,2]#P[0]*P[1]*e15
    deP_dPz[2,2,0] = deP_dPz[2,0,2]#P[0]*P[2]*e15 + 2*P[0]*P[2]*em

    deP_dPx[2,2,1] = deP_dPx[2,1,2]#P[0]*P[1]*e15
    deP_dPy[2,2,1] = deP_dPy[2,1,2]#P[1]**2*e15 + P[2]**2*em  + e15*norm_sq/2
    deP_dPz[2,2,1] = deP_dPz[2,1,2]#P[1]*P[2]*e15 + 2*P[1]*P[2]*em

    deP_dPx[2,2,2] = 2*P[0]*(P[2]*e15 + P[2]*e31)
    deP_dPy[2,2,2] = 2*P[1]*(P[2]*e15 + P[2]*e31)
    deP_dPz[2,2,2] = 3*P[2]**2*em  + 2*P[2]*(P[2]*e15 + P[2]*e31) + (e15 + e31)*norm_sq

    # --------------- Derivaive of the spon. strain tensor wrt P ---------------
    deps0_P_dPx = torch.zeros((3,3,*P[0].shape)).to(device)          # Derivaive of spont. strain wrt P[1]
    deps0_P_dPy = torch.zeros((3,3,*P[0].shape)).to(device)           # Derivaive of spont. strain wrt P[2]
    deps0_P_dPz = torch.zeros((3,3,*P[0].shape)).to(device)           # Derivaive of spont. strain wrt P[2]

    deps0_P_dPx[0,0] = 2.0*P[0]*e00
    deps0_P_dPy[0,0] = -1.0*P[1]*e00
    deps0_P_dPz[0,0] = -1.0*P[2]*e00

    deps0_P_dPx[0,1] = 1.5*P[1]*e00
    deps0_P_dPy[0,1] = 1.5*P[0]*e00
    deps0_P_dPz[0,1] = 0

    deps0_P_dPx[0,2] = 1.5*P[2]*e00
    deps0_P_dPy[0,2] = 0
    deps0_P_dPz[0,2] = 1.5*P[0]*e00

    deps0_P_dPx[1,0] = deps0_P_dPx[0,1]
    deps0_P_dPy[1,0] = deps0_P_dPy[0,1]
    deps0_P_dPz[1,0] = deps0_P_dPz[0,1]

    deps0_P_dPx[1,1] = -1.0*P[0]*e00
    deps0_P_dPy[1,1] = 2.0*P[1]*e00
    deps0_P_dPz[1,1] = -1.0*P[2]*e00

    deps0_P_dPx[1,2] = 0
    deps0_P_dPy[1,2] = 1.5*P[2]*e00
    deps0_P_dPz[1,2] = 1.5*P[1]*e00

    deps0_P_dPx[2,0] = deps0_P_dPx[0,2]
    deps0_P_dPy[2,0] = deps0_P_dPy[0,2]
    deps0_P_dPz[2,0] = deps0_P_dPz[0,2]

    deps0_P_dPx[2,1] = deps0_P_dPx[1,2]
    deps0_P_dPy[2,1] = deps0_P_dPy[1,2]
    deps0_P_dPz[2,1] = deps0_P_dPz[1,2]

    deps0_P_dPx[2,2] = -1.0*P[0]*e00
    deps0_P_dPy[2,2] = -1.0*P[1]*e00
    deps0_P_dPz[2,2] = 2.0*P[2]*e00

    # --------------- Derivaive of the elastic strain tensor wrt P -------------
    deps_elas_dPx = -deps0_P_dPx
    deps_elas_dPy = -deps0_P_dPy
    deps_elas_dPz = -deps0_P_dPz

    # delete unused tensors
    del deps0_P_dPx, deps0_P_dPy, deps0_P_dPz, norm_sq

    # return derivatives
    return deP_dPx, deP_dPy, deP_dPz, deps_elas_dPx, deps_elas_dPy, deps_elas_dPz
</code></pre>


</section>

<section id="energies_and_their_derivatives">
    <h3>Energy Calculations and Their Derivatives</h3>
    <p>
      In this section, we provide Python code to compute the bulk energy contributions and their derivatives with respect to polarization, essential components of phase-field simulations.
    </p>
    <p>
      The <b>bulk energy</b> includes elastic, piezoelectric, and electric energy contributions. The code also includes the derivative of the Landau polynomial, which is often used to describe the free energy of ferroelectric materials.
    </p>
    <p>
      Below is the implementation, where we calculate both the energy components and their derivatives with respect to polarization. 
    </p>
<pre><code class="language-python">import torch

def Bulk_Energy(C0:torch.Tensor, eps_elas:torch.Tensor,
                    eP:torch.Tensor, E:torch.Tensor, K:torch.Tensor, P:torch.Tensor):

    """
    Calculates the bulk energy = elastic + piezoelectric + electric energies.
    Reeturn elastic, piezoelectric, electric energies

    C0 - homogeneous stiffness tensor

    eps_elas - elastic strain

    eP - piezoelectric tesnor

    E - total electric FIELD

    K - dielectric tesnor

    P - spontaneous polarization
    """

    # Elastic energy
    H_elas = 0.5 * np.einsum('ijkl, ijxyz, klxyz -> xyz', C0, eps_elas, eps_elas)

    # Piezoelectric energy
    H_piezo = -np.einsum('ijkxyz, ijxyz, kxyz -> xyz', eP, eps_elas, E)

    # Electric energy
    H_elec = -np.einsum('ij,ixyz,jxyz->xyz', K, E, E) - np.einsum('ixyz,ixyz->xyz',P,E)

    # return those energies
    return H_elas, H_piezo, H_elec

def Bulk_Energy_Derivative(C0:torch.Tensor, eps_elas:torch.Tensor, eP:torch.Tensor,
                            E:torch.Tensor, deP_dPx:torch.Tensor, deP_dPy:torch.Tensor,
                            deP_dPz:torch.Tensor, deps_elas_dPx:torch.Tensor,
                            deps_elas_dPy:torch.Tensor, deps_elas_dPz:torch.Tensor):
    """
    Calculates the derivatives of the energies.
    Returns the derivative of the elastic, piezoelectric and electric energies wrt to polarization.

    C0 - homogeneous stiffness tensor

    eps_elas - elastic strain

    eP - piezoelectric tesnor

    E - total electric FIELD

    deP_dPx, deP_dPy, deP_dPz - derivatives piezoelectric tensor wrt Px, Py, Pz

    deps_elas_dPx, deps_elas_dPy, deps_elas_dPz - derivatives of sponteneous strain tensor wrt Px, Py, Pz

    """
    # Derivaive of the elastic energy
    dH_elas_dPx = 0.5*(torch.einsum('ijkl, ijxyz, klxyz -> xyz', C0, deps_elas_dPx, eps_elas) +
                        torch.einsum('ijkl, ijxyz, klxyz -> xyz', C0, eps_elas, deps_elas_dPx) )
    dH_elas_dPy = 0.5*(torch.einsum('ijkl, ijxyz, klxyz -> xyz', C0, deps_elas_dPy, eps_elas) +
                        torch.einsum('ijkl, ijxyz, klxyz -> xyz', C0, eps_elas, deps_elas_dPy) )
    dH_elas_dPz = 0.5*(torch.einsum('ijkl, ijxyz, klxyz -> xyz', C0, deps_elas_dPz, eps_elas) +
                        torch.einsum('ijkl, ijxyz, klxyz -> xyz', C0, eps_elas, deps_elas_dPz) )

    dH_elas_dP = torch.stack((dH_elas_dPx, dH_elas_dPy, dH_elas_dPz))

    del dH_elas_dPx, dH_elas_dPy, dH_elas_dPz

    # Derivaive of the piezoelectric energy
    dH_piezo_dPx = -(torch.einsum('ijkxyz, ijxyz, kxyz -> xyz', deP_dPx, eps_elas, E) +
                        torch.einsum('ijkxyz, ijxyz, kxyz -> xyz', eP, deps_elas_dPx, E) )
    dH_piezo_dPy = -(torch.einsum('ijkxyz, ijxyz, kxyz -> xyz', deP_dPy, eps_elas, E) +
                        torch.einsum('ijkxyz, ijxyz, kxyz  -> xyz', eP, deps_elas_dPy, E) )
    dH_piezo_dPz = -(torch.einsum('ijkxyz, ijxyz, kxyz -> xyz', deP_dPz, eps_elas, E) +
                        torch.einsum('ijkxyz, ijxyz, kxyz -> xyz', eP, deps_elas_dPz, E) )

    dH_piezo_dP = torch.stack((dH_piezo_dPx, dH_piezo_dPy, dH_piezo_dPz))

    del dH_piezo_dPx, dH_piezo_dPy, dH_piezo_dPz

    # derivative of the electric energy
    dH_elec_dP = -E

    # Derivative of the bulk energy
    dH_bulk_dP = dH_elas_dP + dH_piezo_dP + dH_elec_dP

    del dH_elas_dP, dH_piezo_dP, dH_elec_dP

    return dH_bulk_dP

def Landau_Polynomial_Derivative(P, a1, a2, a3, a4):
    
    """
    Calculates the derivative of the Landau polynomial wrt P

    P - spontaneous polarization

    a1, a2, a3, a4 - polynomial coefficients
    """

    dPsi_dPx = a1 * 2*P[0] + a2 * 4*P[0]**3 + a3 * 2*P[0] * (P[1]**2 + P[2]**2) + a4 * 6*P[0]**5
    dPsi_dPy = a1 * 2*P[1] + a2 * 4*P[1]**3 + a3 * 2*P[1] * (P[0]**2 + P[2]**2) + a4 * 6*P[1]**5
    dPsi_dPz = a1 * 2*P[2] + a2 * 4*P[2]**3 + a3 * 2*P[2] * (P[0]**2 + P[1]**2) + a4 * 6*P[2]**5

    # combine them
    dPsi_dP = torch.stack((dPsi_dPx, dPsi_dPy, dPsi_dPz))

    del dPsi_dPx, dPsi_dPy, dPsi_dPz

    return dPsi_dP
    </code></pre>
    
</section>

<section id="data_management">
<h2>Data Management</h2>
<p>
  Efficient data management is crucial for phase-field simulations, as these models often produce large volumes of data. 
  Proper storage and organization of this data enable post-processing, visualization, and reproducibility of results. 
  In this section, we explore two common methods for saving polarization data: <b>VTK files</b> and <b>HDF5 files using the h5py library</b>. 
  Each has distinct advantages, depending on your needs.
</p>
</section>

<section id="vtk">
  <h3>Option 1: Writing Polarization Data to VTK Files</h3>
  <p>
    VTK (Visualization Toolkit) files are widely used for scientific visualization, particularly in tools like ParaView. 
    Writing polarization data to VTK files allows for immediate and intuitive visualization of simulation results in 2D or 3D.
  </p>
  <p><b>Advantages of Using VTK Files:</b></p>
  <p>
    VTK files integrate seamlessly with ParaView and other visualization software, allowing you to visualize scalar or 
    vector fields without additional conversion steps.
  </p>
  <p>
    ASCII VTK files are text-based and can be opened and inspected for debugging or verification purposes.
  </p>
  <p>
    The VTK format natively supports structured grids, making it ideal for phase-field data on regular grids.
  </p>
  <p><b>Limitations:</b></p>
  <p>
    ASCII VTK files can become large, especially for 3D simulations with fine resolutions.
  </p>
  <p>
    VTK files are not ideal for storing additional metadata (e.g., simulation parameters).
  </p>
  <p>We can create now another file for this <code>write_vtk.py</code></p>
<pre><code class="language-python">def write_vtk(step, polarization, dx, dy, dz):

  """
  Write a VTK file with polarization vector data.

  Parameters:
      - filename (str): The name of the VTK file to be created.
      - polarization (numpy.ndarray): The polarization vector with shape (3, Nx, Ny, Nz).
      - dx (float): Grid spacing along the x-axis.
      - dy (float): Grid spacing along the y-axis.
      - dz (float): Grid spacing along the z-axis.
  """

   # Ensure the polarization vector has the correct shape
  assert polarization.shape[0] == 3, "Polarization vector should have shape (3, Nx, Ny, Nz)"

  Nx, Ny, Nz = polarization.shape[1], polarization.shape[2], polarization.shape[3]

  with open("time_" + str(step) + ".vtk", 'w') as vtk_file:

      # Write VTK header
      vtk_file.write("# vtk DataFile Version 2.0\n")
      vtk_file.write("Polarization Data\n")
      vtk_file.write("ASCII\n")
      vtk_file.write("DATASET STRUCTURED_GRID\n")
      vtk_file.write(f"DIMENSIONS {Nx} {Ny} {Nz}\n")
      vtk_file.write(f"POINTS {Nx*Ny*Nz} float\n")

      # Write grid point coordinates
      for k in range(Nz):
          for j in range(Ny):
              for i in range(Nx):
                  vtk_file.write(f"{i*dx} {j*dy} {k*dz}\n")

      # Write point data header
      vtk_file.write(f"POINT_DATA {Nx*Ny*Nz}\n")
      vtk_file.write("VECTORS polarization float\n")

      # Write polarization vector data
      for k in range(Nz):
          for j in range(Ny):
              for i in range(Nx):
                  vtk_file.write(f"{polarization[0, i, j, k]} {polarization[1, i, j, k]} {polarization[2, i, j, k]}\n")


</code></pre>
  
</section>

<section id="h5py">
  <h3>Option 2: Storing Data Using HDF5</h3>
  <p>
    HDF5 is a high-performance, hierarchical data format designed for storing large numerical datasets. 
    The <code>h5py</code> library provides a Python interface to efficiently write and read HDF5 files.
  </p>
  <p><b>Advantages of Using HDF5 Files:</b></p>
  <p>
    HDF5 files are binary, resulting in smaller file sizes compared to ASCII formats like VTK.
  </p>
  <p>
    Data can be organized into groups and datasets, enabling you to store polarization fields alongside simulation metadata 
    (e.g., time steps, parameters).
  </p>
  <p>
    HDF5 handles very large datasets efficiently, making it suitable for simulations with high spatial and temporal resolution.
  </p>
  <p>
    The format can store various types of data (e.g., scalars, vectors, and multidimensional arrays) in a single file.
  </p>
  <p>Here is the code for <code>store_hdf5.py</code></p>
<pre><code class="language-python">import h5py

def Write_to_HDF5(step, P, **kwargs):
    """
    Saves simulation results, including polarization and optional parameters, to an HDF5 file.

    Parameters:
        step (int): Current simulation time step or identifier.
        P (list): Polarization tensor components as a list of numpy arrays [Px, Py, Pz].
        **kwargs: Optional keyword arguments to save additional data, such as:
            - 'ElasticStrain': Elastic strain tensor components (3x3 numpy array).
            - 'ElectricField': Electric field tensor components as a list [Ex, Ey, Ez].
            - 'SimulationParams': Dictionary of simulation parameters.

    The data is stored hierarchically in the HDF5 file for efficient access and organization.
    """
    # Open or create the HDF5 file in append mode
    with h5py.File('results.h5', 'a') as hdf:
        # Define the time step group for this set of results
        time = f'/time_{int(step)}'

        # Save the polarization tensor components
        hdf.create_dataset(f'Polarization/Px{time}', data=P[0])
        hdf.create_dataset(f'Polarization/Py{time}', data=P[1])
        hdf.create_dataset(f'Polarization/Pz{time}', data=P[2])

        # Save additional data based on the provided keyword arguments
        for key, value in kwargs.items():
            if key == 'ElasticStrain':
                # Save components of the elastic strain tensor
                hdf.create_dataset(f'Elastic strain/strain_XX{time}', data=value[0, 0])
                hdf.create_dataset(f'Elastic strain/strain_XY{time}', data=value[0, 1])
                hdf.create_dataset(f'Elastic strain/strain_XZ{time}', data=value[0, 2])
                hdf.create_dataset(f'Elastic strain/strain_YY{time}', data=value[1, 1])
                hdf.create_dataset(f'Elastic strain/strain_YZ{time}', data=value[1, 2])
                hdf.create_dataset(f'Elastic strain/strain_ZZ{time}', data=value[2, 2])

            elif key == 'ElectricField':
                # Save components of the electric field tensor
                hdf.create_dataset(f'Electric field/Ex{time}', data=value[0])
                hdf.create_dataset(f'Electric field/Ey{time}', data=value[1])
                hdf.create_dataset(f'Electric field/Ez{time}', data=value[2])

            elif key == 'SimulationParams':
                # Save simulation parameters
                sim_params = value
                sim_params_group = hdf.create_group('Simulation_Parameters')
                
                # Iterate through the simulation parameters dictionary and save each parameter
                for param_name, param_value in sim_params.items():
                    sim_params_group.create_dataset(param_name, data=param_value)
</code></pre>
</section>

<section id="materials_parameters">
<h2>Material Parameters</h2>
<p>
  Now, let's create another file called <code>parameters.py</code>. In this file, you will store material properties and coefficients 
  for the Landau polynomial, which are key components of the simulation. Additionally, you will define a function named 
  <code>initial_polarization</code>. This function will generate initial polarization configurations with various domain types, 
  such as random distributions, 180° or 90° domain walls, or sharp interfaces. Here is the code:
</p>
<pre><code class="language-python">"""
This file contains all the data necessary for the phase-field simulations

Material data:
    - store all material parameters here
    - function BTO_3D() contains material parameters for BTO

Initial polarization can also be imported from here for different domain types:
    - random -> polarization vector field starts with an initial
                uniform distribution over [-0.1, +0.1]
    - 90 -> polarization vector field starts with three 90° sharp interfaces
            Note, here must be Nx=Ny
    - 180 -> polarization vector field starts with a single 180° sharp interface
"""

import numpy as np
import itertools
import torch

# Functions to convert Voigt to full tensors
def full_3x3_to_Voigt_6_index_3D(i, j):
    if i == j:
        return i
    return 6-i-j

def Voigt_to_full_Tensor_3D(C):
    C = np.asarray(C)
    C_out = np.zeros((3,3,3,3), dtype=np.float32)
    for i, j, k, l in itertools.product(range(3), range(3), range(3), range(3)):
        Voigt_i = full_3x3_to_Voigt_6_index_3D(i, j)
        Voigt_j = full_3x3_to_Voigt_6_index_3D(k, l)
        C_out[i, j, k, l] = C[Voigt_i, Voigt_j]
    return C_out

def Landau_Polynomial_Coeffs():
    """
    Returns the Landau polynomial coefficients.
    """
    a1, a2, a3, a4 = -0.1, -2.8, -3.8, 1.9

    return a1, a2, a3, a4

def BTO_3D():

    G       = 12e-3                       # J/m²=N/m Interfacial Energy
    l_wall  = 1.5E-9                      # m: Thickness of interface: Length Scale
    P0      = 0.26                        # C/m²: Maximum polarization
    mob     = 26/75*1e3                   # A/Vm: mobility beta^-1
    c_tet   = 4.032                         # angstrom
    a_tet   = 3.992                         # angstrom
    e00     = 2*(c_tet-a_tet)/(c_tet+2*a_tet)

      # ----------------------- MATERIAL PARAMETERS ----------------------------
    k_sep   = 0.70    # Separation coefficient
    k_grad  = 0.35   # Gradient Energy coefficient

    # piezoelectric tensor components
    e31, e33, e15 = (-0.7, 6.7, 34.2)  # e33 = 6.7
    # e_ver = e33; e_per = e31; e_hor = e15

    # Elastic tensor comps
    C11 = 22.2e10
    C12 = 11.1e10
    C44 = 6.1e10

    C_cub = np.array([[C11, C12, C12, 0, 0, 0],
                      [C12, C11, C12, 0, 0, 0],
                      [C12, C12, C11, 0, 0, 0],
                      [0,   0,   0, C44, 0, 0],
                      [0,   0,   0, 0, C44, 0],
                      [0,   0,   0, 0, 0, C44]])

    C0 = torch.tensor(Voigt_to_full_Tensor_3D(C_cub))

    k = 19.5e-9

    K0 = torch.eye(3)*k
    return G, l_wall, P0, mob, e00, k_sep, k_grad, e31, e33, e15, C0, K0

# Inital polarization
def initial_polarization(Nx, Ny, domain_type, Nz):

    torch.manual_seed(51254)
    print("Initial polarization for 3D simulations")

    if domain_type == 'random':

        # generates random initial polarization
        Px = (0.1 * (2.0 * torch.rand(Nx, Ny, Nz) - 1.0))#.requires_grad_()
        Py = (0.1 * (2.0 * torch.rand(Nx, Ny, Nz) - 1.0))#.requires_grad_()
        Pz = (0.1 * (2.0 * torch.rand(Nx, Ny, Nz) - 1.0))#.requires_grad_()

    elif domain_type == '180':

        # generates a single 180° DW
        print("180° domain type")
        Px = torch.zeros((Nx,Ny,Nz))
        Py = torch.zeros((Nx,Ny,Nz))
        Pz = torch.ones((Nx,Ny,Nz))
        Pz[:,int(Ny/2):,:]=-1

    elif domain_type == '90':

        # generates 90° DW structure
        from scipy import linalg
        first_row = torch.zeros(Nz)
        nn=Nz/2
        first_row[:int(nn)]=1
        first_row[2*int(nn)-1:3*int(nn)]=1

        first_col = torch.ones(Ny)
        first_col[:int(nn)]=0
        first_col[2*int(nn)-1:3*int(nn)]=0

        Pyy = torch.from_numpy(linalg.toeplitz(first_col, first_row))
        Pxx = (1-Pyy)*-1
        # create 90° DW in yz plane
        Px = torch.zeros((Nx,Ny,Nz))
        Py = torch.zeros((Nx,Ny,Nz))
        Py[:] = Pxx
        Pz = torch.zeros((Nx,Ny,Nz))
        Pz[:] = Pyy

        print(Px.shape, Py.shape, Pz.shape)

    elif domain_type == 'minus_z':
        Px = torch.zeros((Nx,Ny,Nz))
        Py = torch.zeros((Nx,Ny,Nz))
        Pz = -torch.ones((Nx,Ny,Nz))

    elif domain_type == 'plus_z':
        Px = torchp.zeros((Nx,Ny,Nz))
        Py = torch.zeros((Nx,Ny,Nz))
        Pz = torch.ones((Nx,Ny,Nz))

    return torch.stack((Px, Py, Pz))
</code></pre>
</section>

<section id="evolve_polarization">
  <h2>
    Polarization Dynamics
  </h2>
  <p>
    Now, let’s implement the polarization equation by writing the EvolvePolarization function in the <code>evolve_polarization.py</code> 
    file. We will use the forward Euler scheme for time evolution, which was introduced earlier in part 1 of this project. 
    The code includes clear comments to guide you through the implementation.
  </p>
  <p>
    The code can be explained as follows:
  </p>
  <p>
    First, ensure that all Python files are in the same directory so you can import them easily into 
    <code>evolve_polarization.py</code>. Then, import the material data and set the initial polarization, 
    whether random, 180°, or 90°. Next, we non-dimensionalize the quantities in the code to avoid numerical 
    errors during calculations.
  </p>
  <p>
    After that, create additional tensors and assign any external fields, such as electric fields or 
    mechanical strain. Once this setup is complete, we calculate the Fourier frequencies and begin 
    the time loop to evolve the simulation.
  </p>
<pre><code class="language-python">import torch
from torch.fft import fftn as fft, ifftn as ifft
#-------------------------------------------------------------------------------
import parameters
import piezo_strain_tensor
import energy
from fourier_frequency import fourier_frequencies
from write_vtk import write_to_vtk3D
from greens_function import Green_Operator
from solver import Solve_Piezoelectricity

def EvolvePolarization(device:torch.device, FOLDER:str, grid_points:tuple, grid_space:tuple, time:tuple,
                                elec_field_ext:tuple, eps_ext_applied:tuple, domain_type:str, save_data:str):
    # ----------------------------------------------------------------------------
    """
    Polarization evolution in 3D with an isotropic gradient energy.

    device - the torch device

    FOLDER - directory where you want to save results

    grid_points - number of grid points in each diection; (Nx, Ny, Nz)

    grid_space - grid spacing in each direction; (dx, dy, dz)

    time - simulation time setup

    elec_field_ext - applied external electric field in each direction; (x, y, z)

    eps_ext_applied - applied external strain in each direction; (x, y, z)

    domain_type - what is you domain type; "180", "90", "random". see parameters.py

    save_data - save the data into VTK file; "YES" or "NO"
    """

    # import material data
    G, l_wall, P0, mob, e00, k_sep, k_grad, e31, e33, e15, C0, K0 = parameters.BTO_3D_Schrade()
    a1, a2, a3, a4 = parameters.Landau_Polynomial_Coeffs_Schrade()
    # ----------------------------------------------------------------------------
    Nx, Ny, Nz = grid_points
    dx, dy, dz = grid_space
    nsteps, nt, dt = time
    # ----------------------------------------------------------------------------
    # Scaling parameters
    l_scale = l_wall  # length scale   m
    G_scale = G/l_wall   # energy scale   J/m³
    P_scale = P0         # polarization scale   C/m²
    E_scale = G_scale/P_scale   # (N/m²)/(C/m²) = N/C = J/(mC) = V/m: Electric Field scale
    D_scale = P_scale           # C/m²: Electric Displacement scale
    K_scale = D_scale/E_scale   # (C/m²)/(V/m) = C/(Vm) Dielectric Permittivity scale
    e_scale = P_scale           # C/m²: Piezoelectric scale
    C_scale = G_scale           # N/m²: Elastic Modulus scale
    t_scale = 1E-12           # s: Time scale
    v_scale = l_scale/t_scale   # m/s   velocity scale
    mob_scale = (P_scale/t_scale)/(G_scale/P_scale) # Mobility scale
    # ----------------------------------------------------------------------------
    # Non dimensionalize
    C0 = C0/C_scale
    e31, e33, e15 = e31/e_scale, e33/e_scale, e15/e_scale
    K0 = K0/K_scale
    mob = mob/mob_scale
    P0 = P0/P_scale
    dt = dt/t_scale
    dx = dx/l_scale
    dy = dy/l_scale
    dz = dz/l_scale
    elec_field_ext[0], elec_field_ext[1], elec_field_ext[2] = elec_field_ext[0]/E_scale, elec_field_ext[1]/E_scale, elec_field_ext[2]/E_scale
    # ----------------------------------------------------------------------------
    C0 = C0.to(device)
    K0 = K0.to(device)
    # ----------------------------------------------------------------------------
    # initial polarization
    P = parameters.initial_polarization(Nx, Ny, domain_type, Nz).to(device)
    # ----------------------------------------------------------------------------
    # frequencies
    freq = fourier_frequencies(Nx, dx, Ny, dy, Nz, dz, device)
    # Save inital polarization -------------------------------------------------
    if save_data == "YES":
        # zero step
        write_to_vtk3D(FOLDER, 0, "Polarization", P.to(torch.device("cpu")),
                            Nx, Ny, Nz, dx, dy, dz)# ----------------------------------------------------------------------------
    # Applied external fields --------------------------------------------------
    eps_ext  = torch.zeros((3,3,Nx,Ny,Nz)).to(device)             # applied elas. field
    eps_ext[0, 0] = eps_ext_applied[0] # in x
    eps_ext[1, 1] = eps_ext_applied[1] # in y
    eps_ext[2, 2] = eps_ext_applied[2] # in z

    E_ext = torch.zeros((3,Nx,Ny,Nz)).to(device)              # applied elec. field
    E_ext[0] = elec_field_ext[0]   # in x
    E_ext[1] = elec_field_ext[1]   # in y
    E_ext[2] = elec_field_ext[2]   # in z
    # ----------------------------------------------------------------------------
    denom = 1 + dt * mob * k_grad * (freq[0]**2 + freq[1]**2 + freq[2]**2)
    # ----------------------------------------------------------------------------
    for step in range(nsteps):
        # applied as sine function
        # ------------------------------------------------------------------------
        print('\n---------------------- Time step:\t' + str(step)+'\t----------------------')
        # -------------------------------------------------------------------------
        eP, e0, eps0 = piezo_strain_tensor.Piezo_Strain_Tensor(P, e33, e31, e15, e00, device)
        deP_dPx, deP_dPy, deP_dPz, deps_elas_dPx, deps_elas_dPy, deps_elas_dPz = piezo_strain_tensor.Piezo_Strain_Tensor_Derivative(P, e33, e31, e15, e00, device)
        # -------------------------------------------------------------------------
        G_elas, G_piezo, G_dielec = Green_Operator(C0, e0, K0, freq, Nx, Ny, Nz, device)
        # ------------------------------------------------------------------------
        sigma, D, eps_elas, E = Solve_Piezoelectricity(C0,K0,e0,eP,G_elas,G_piezo,G_dielec,eps0,eps_ext,E_ext,Nx,Ny,Nz,P)
        # ------------------------------------------------------------------------
        del G_elas, G_piezo, G_dielec
        # ------------------------------------------------------------------------
        dH_bulk_dP = energy.Bulk_Energy_Derivative(C0, eps_elas, eP, E, deP_dPx, deP_dPy, deP_dPz, deps_elas_dPx, deps_elas_dPy, deps_elas_dPz)
        # ------------------------------------------------------------------------
        dPsi_dP = energy.Landau_Polynomial_Derivative(P, a1, a2, a3, a4)
        # ------------------------------------------------------------------------
        dH_dP =  k_sep * dPsi_dP + dH_bulk_dP
        # ------------------------------------------------------------------------
        dH_dP_k = fft(dH_dP, dim=(1,2,3))
        del dH_dP, dPsi_dP, dH_bulk_dP
        # ------------------------------------------------------------------------
        P_k = fft(P, dim=(1,2,3))
        # ------------------------------------------------------------------------
        P_k = (P_k - dt * mob * dH_dP_k) / denom
        # ------------------------------------------------------------------------
        P = ifft(P_k, dim=(1,2,3)).real
        # ------------------------------------------------------------------------
        if ((step + 1) % nt == 0 and save_data == "YES"):
            # --------------------------------------------------------------------
            write_to_vtk3D(FOLDER, step + 1, "Polarization", P.to(torch.device("cpu")),
                                Nx, Ny, Nz, dx, dy, dz)
            # --------------------------------------------------------------------
        del sigma, D, eps_elas, E
</code></pre>
<div class="important-box">
  <p>
    It is important to save polarization data and the simulation parameters because a simulation might stop unexpectedly due to insufficient memory or other issues. To avoid rerunning everything from the beginning, you should save the data at regular intervals defined by a specific time frame, <code>nt</code>.
  </p>
</div>
</section>

<secion id="main">
<h2>Execute Simulation</h2>
<p>
  Now, we create a file <code>main.py</code> to execute the simulation. It just contains the simulation grid and time parameters
and runs the polarization evolution from <code>evolve_polarization.py</code>
</p>
<pre><code class="language-python">import torch
import timeit
import os
import resource

import evolve_polarization

def main():

    print("\n==================== PHASE-FIELD SIMULATIONS =======================\n")

    # Start time
    start_tm = timeit.default_timer()

    # Device agnostic code
    if torch.cuda.is_available():
        device = torch.device("cuda")  # Use CUDA device
        print("CUDA is available. Using GPU.")
        print(torch.cuda.get_device_name(0))
    else:
        device = torch.device("cpu")  # Use CPU
        print("CUDA is not available. Using CPU.")

    # ------------------------- SIMULATIONS PARAMETERS -------------------------
    grid_points = (120, 120, 120) # (Nx, Ny, Nz)
    grid_space = (5e-10, 5e-10, 5e-10) # (dx, dy, dz) in [m]

    # time parameters: nsteps - number of time steps, nt- time frame to save data
    time = (30000, 100, 1e-13)   # (nsteps, nt, dt), dt is in [sec]

    # external electric field in each direction
    elec_field_ext = (0, 0, 0)  # (E_app_x, E_app_y, E_app_z) must be in V/m

    # external applied strain in each direction
    eps_ext_applied = (0, 0, 0) # (eps_app_x, eps_app_y, eps_app_z)

    # maximum electric field of the hysteresis loop
    E_max_loop = (0, 2) # (E, direction) E must be in V/m, direction: x=0, y=1, z=2

    # domain_type = "random" OR "90" OR "180" OR "minus_z"
    domain_type = "random"

    # saves the results, "YES" or "NO"
    save_data = "YES"

    # directory to save results
    FOLDER = os.getcwd()

    # Evolve
    evolve_polarization.EvolvePolarization(device, FOLDER, grid_points, grid_space, time,
                                    elec_field_ext, eps_ext_applied, domain_type, save_data)
    # ----------------------------------------------------------------------------
    stop_tm = timeit.default_timer()
    print("\n====================== SIMULATIONS  FINISHED =========================\n")
    print('Execution time: ' + str( format((stop_tm - start_tm)/60,'.3f')) + ' min' )
    print('\nSimulation parameters:')
    print('Grid points = ', grid_points)
    print('Grid space = ', grid_space)
    print('Time setup = ', time)

    # Get memory usage after execution in kilobytes
    usage_kb = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss

    # Convert to megabytes and gigabytes for printing
    usage_mb = usage_kb / 1024  # Convert to megabytes
    usage_gb = usage_mb / 1024   # Convert to gigabytes

    print(f"Memory usage: {usage_gb:.4f} GB")  # Print memory usage in GB with two decimal places
    print("========================================================================")

if __name__ == "__main__":
    main()
</code></pre>

</secion>

</div>
  </main>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      // Select all TOC links
      const tocLinks = document.querySelectorAll(".toc a");
  
      tocLinks.forEach(link => {
        link.addEventListener("click", (e) => {
          e.preventDefault(); // Prevent default anchor behavior
          const targetId = link.getAttribute("href").substring(1); // Get the target ID
          const targetElement = document.getElementById(targetId);
  
          if (targetElement) {
            const offset = 130; // Adjust this to match your header's height
            const topPosition = targetElement.getBoundingClientRect().top + window.scrollY - offset;
  
            // Scroll to the adjusted position
            window.scrollTo({
              top: topPosition,
              behavior: "smooth"
            });
          }
        });
      });
    });
  </script>

  <!-- <footer>
    <p>&copy; 2025 Dilshod Durdiev</p>
  </footer> -->
</body>
</html>
